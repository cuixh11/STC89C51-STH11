C51 COMPILER V9.02   ALARM                                                                 04/02/2022 12:21:45 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE ALARM
OBJECT MODULE PLACED IN ..\output\alarm.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\alarm.c BROWSE INCDIR(..\inc) DEBUG OBJECTEXTEND PRINT(.\alarm.lst) 
                    -OBJECT(..\output\alarm.obj)

line level    source

   1          /*
   2          *******************************************************************************
   3          *文 件 名：alarm.c
   4          *描    述：第三部分报警设置
   5          *  版本号：v1.0.0  
   6          ;微处理器: STC89C51
   7          ;编译环境: Keil uVision V4.10 
   8          ;作    者: Cui Xinghai 
   9          ;创建日期: 2022.2.24   
  10          ; 备   注：
  11          *******************************************************************************
  12          */
  13          #define  _alarm_C
  14          #include "alarm.h"
  15          #include "LCD1602.h"
  16          #include "STH11.h"
  17          
  18          #include <reg52.h>
  19          #include <math.h>    //Keil library   
  20          
  21          //*********************第三部分报警设置   START****************************************
  22          sbit  t_green   =  P1^0;
  23          sbit  t_red     =  P1^1;
  24          sbit  rh_green  =  P1^2;
  25          sbit  rh_red    =  P1^3;
  26          
  27          int t_shangxian = 20;            //上限报警温度，默认值为 20C
  28          int t_xiaxian   = 10;            //下限报警温度，默认值为 10C
  29          int rh_shangxian= 50;            //上限报警湿度，默认值为50%
  30          int rh_xiaxian  = 40;            //下限报警湿度，默认值为40%
  31          
  32          unsigned char flag=0;
  33          
  34          /*-------------------------------------- 
  35          ;模块名称:led_control(); 
  36          ;功    能:LED状态控制
  37          ;-------------------------------------*/ 
  38          void led_control( float *WENDU,  float *SHIDU)                   
  39          {
  40   1      //温度过低报警指示
  41   1        if(*WENDU <= t_xiaxian)    {t_green = 0;}
  42   1        else {t_green=1;}
  43   1      //温度过高报警指示
  44   1        if(*WENDU >= t_shangxian)  {t_red   = 0;}
  45   1        else {t_red=1;}
  46   1      //湿度过低报警指示
  47   1        if(*SHIDU <= rh_xiaxian)   {rh_green= 0;}
  48   1        else {rh_green=1;}
  49   1      //湿度过高报警指示
  50   1        if(*SHIDU >= rh_shangxian) {rh_red  = 0;}
  51   1        else {rh_red=1;}
  52   1      //蜂鸣器警示
  53   1        if(*WENDU <= t_xiaxian||*WENDU >= t_shangxian||*SHIDU <= rh_xiaxian||*SHIDU >= rh_shangxian)
  54   1        {
C51 COMPILER V9.02   ALARM                                                                 04/02/2022 12:21:45 PAGE 2   

  55   2          BEEP = 0;
  56   2        }
  57   1        else 
  58   1        {
  59   2          BEEP = 1;
  60   2        }
  61   1      }
  62          
  63                     
  64          /*-------------------------------------- 
  65          ;模块名称:key(); 
  66          ;功    能:按键控制
  67          ;-------------------------------------*/ 
  68          void key()   
  69          {
  70   1      /****************设置键设置****************/
  71   1       if(SET == 0)
  72   1        {
  73   2          delay(50);               //按键消抖
  74   2          if(SET == 0)
  75   2           {
  76   3            flag++;
  77   3            if (flag==5)flag = 0;  //没有发生抖动
  78   3                while(SET==0);         //若一直按下，循环
  79   3      
  80   3          LCD_init(); 
  81   3          s_connectionreset();     
  82   3          LCD_disp_str(0,1,"TE:");
  83   3          LCD_disp_str(0,2,"RH:"); 
  84   3              LCD_disp_str(6,1,"-"); 
  85   3              LCD_disp_str(6,2,"-");
  86   3              LCD_disp_str(10,1,"C");
  87   3              LCD_disp_str(10,2,"%");
  88   3          delay_n10us(20);      
  89   3          }
  90   2      
  91   2        }
  92   1      //SHT11湿度测量范围：0～100%RH；温度测量范围：-40～+123.8℃；
  93   1      /****************温度下限设置****************/
  94   1              if (flag==1)                                  
  95   1           {
  96   2            if(ADD==0)
  97   2                 {
  98   3                  delay(50);
  99   3                  t_xiaxian++;
 100   3                  if (t_xiaxian>(t_shangxian-1)) {t_xiaxian=(t_shangxian-1);}
 101   3                      while(ADD==0);                                        //加上此句必须松按键才处理
 102   3                 }
 103   2                 if (DEC==0)
 104   2                 {
 105   3                  delay(50);              
 106   3                  if(t_xiaxian<=-40)    {t_xiaxian=t_shangxian;}            //超过实际范围，重新赋值温度下限
 107   3                  else                                   t_xiaxian--;
 108   3                  while(DEC==0);                                        //加上此句必须松按键才处理
 109   3                 }
 110   2             //温度下限显示
 111   2                      LCD_disp_char(3,1,t_xiaxian/100+'0');                 //例如123/100=1 
 112   2                      LCD_disp_char(4,1,abs(t_xiaxian%100/10)+'0');         //例如123%100=23,23/10 =2 ,-12取绝对值12    
 113   2              LCD_disp_char(5,1,abs(t_xiaxian%10)+'0');                         //例如123%10 =3
 114   2              if(t_xiaxian<0)    {LCD_disp_str(12,2,"nega");}       //温度下限为负数，显示nega
 115   2                      else                       {LCD_disp_str(12,2,"    ");}           //去除负数提醒nega
 116   2               }
C51 COMPILER V9.02   ALARM                                                                 04/02/2022 12:21:45 PAGE 3   

 117   1      
 118   1      /****************温度上限设置****************/
 119   1              if (flag==2)              
 120   1                {
 121   2                 if(ADD==0)
 122   2                 {
 123   3                  delay(150);
 124   3                  t_shangxian++;
 125   3                  if (t_shangxian>123) {t_shangxian=123;}              //上限值达到最大值 123时，上限值保持为123
 126   3                  while(ADD==0);                                       //加上此句必须松按键才处理
 127   3                 }
 128   2                 if (DEC==0)
 129   2                 {
 130   3                  delay(150);
 131   3                  t_shangxian--;
 132   3                  if (t_shangxian<(t_xiaxian+1)) {t_shangxian=(t_xiaxian+1);}//确保设定的上限值不比下限低
 133   3                  while(DEC==0);                                       //加上此句必须松按键才处理
 134   3                 }
 135   2             //温度上限显示
 136   2                      LCD_disp_char(7,1,t_shangxian/100+'0');
 137   2                  LCD_disp_char(8,1,(t_shangxian%100)/10+'0');          
 138   2                  LCD_disp_char(9,1,(t_shangxian%10)+'0');       
 139   2                }
 140   1      
 141   1      /****************湿度下限设置****************/
 142   1              if (flag==3)             
 143   1                {
 144   2                 if(ADD==0)
 145   2                 {
 146   3                  delay(150);
 147   3                  rh_xiaxian++;
 148   3                  if (rh_xiaxian>(rh_shangxian-1)) {rh_xiaxian=(rh_shangxian-1);}
 149   3                  while(ADD==0);                                      //加上此句必须松按键才处理
 150   3                 }
 151   2                 if (DEC==0)
 152   2                 {
 153   3                  delay(150);    
 154   3                  if (rh_xiaxian<=0) {rh_xiaxian=0;}                                  //下限值达到最小值0时，下限值保持为0
 155   3                  else rh_xiaxian--;
 156   3                  while(DEC==0);                                      //加上此句必须松按键才处理
 157   3                 }
 158   2             //湿度下限显示
 159   2                      LCD_disp_char(3,2,rh_xiaxian/100+'0');
 160   2                  LCD_disp_char(4,2,(rh_xiaxian%100)/10+'0');               
 161   2                  LCD_disp_char(5,2,(rh_xiaxian%10)+'0');
 162   2                }
 163   1      
 164   1      
 165   1      /****************湿度上限设置****************/
 166   1          if (flag==4)              
 167   1                {
 168   2                 if(ADD==0)
 169   2                 {
 170   3                  delay(150);
 171   3                  rh_shangxian++;
 172   3                  if (rh_shangxian>99) {rh_shangxian=99;}            //上限值达到最大值 99时，上限值保持为 99
 173   3                  while(ADD==0);                                     //加上此句必须松按键才处理
 174   3                 }
 175   2                 if (DEC==0)
 176   2                 {
 177   3                  delay(150);
 178   3                  rh_shangxian--;
C51 COMPILER V9.02   ALARM                                                                 04/02/2022 12:21:45 PAGE 4   

 179   3                  if (rh_shangxian<(rh_xiaxian+1)) {rh_shangxian=(rh_xiaxian+1);}//确保设定的上限值不比下限低
 180   3                  while(DEC==0);                                     //加上此句必须松按键才处理
 181   3                 }
 182   2             //湿度上限显示
 183   2                      LCD_disp_char(7,2,rh_shangxian/100+'0');         
 184   2                  LCD_disp_char(8,2,(rh_shangxian%100)/10+'0');          
 185   2                  LCD_disp_char(9,2,(rh_shangxian%10)+'0');     
 186   2                }
 187   1      
 188   1      /****************退出键设置****************/                                         
 189   1      if(ESC==0)                     
 190   1       {                                         
 191   2        delay(10);
 192   2        if(ESC==0)
 193   2          {           
 194   3               while(ESC==0);
 195   3               flag=0;
 196   3           LCD_init(); 
 197   3           s_connectionreset();     
 198   3           }
 199   2      
 200   2        }
 201   1      }  
 202          
 203          
 204          /*-------------------------------------- 
 205          ;模块名称:delay(); 
 206          ;功    能:延迟函数
 207          ;-------------------------------------*/
 208          void delay(uint j)                        //1ms，j取20
 209          {
 210   1              uchar i=250;
 211   1              for(;j>0;j--)
 212   1              {
 213   2                      while(--i);
 214   2                      i=249;
 215   2                      while(--i);
 216   2                      i=250;
 217   2              }
 218   1      }
 219          
 220          //*********************第三部分报警设置   END****************************************
 221          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1125    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
